package fipa

import (
	"log"

	gAgents "github.com/totoual/gAgents/agent"
)

type UniversalHandler struct {
	agent          *gAgents.Agent
	businessLogics map[Performative]BusinessLogic
}

func NewUniversalHandler(agent *gAgents.Agent) *UniversalHandler {
	return &UniversalHandler{
		agent:          agent,
		businessLogics: make(map[Performative]BusinessLogic),
	}
}

func (h *UniversalHandler) SetBusinessLogic(performative Performative, logic BusinessLogic) {
	h.businessLogics[performative] = logic
}

func (h *UniversalHandler) HandleMessage(envelope gAgents.Envelope) {
	m, err := envelope.ToMessage(&FIPAMessage{})
	if err != nil {
		log.Printf("Error deserializing message: %v", err)
		return
	}

	fipaMsg, ok := m.(*FIPAMessage)
	if !ok {
		log.Println("Couldn't type cast to FIPAMessage")
		return
	}

	h.processMessage(fipaMsg)
}

func (h *UniversalHandler) processMessage(fipaMsg *FIPAMessage) {
	logic, exists := h.businessLogics[fipaMsg.Performative]
	if !exists {
		log.Printf("No business logic defined for performative: %v", fipaMsg.Performative)
		return
	}

	response := logic.Apply(fipaMsg.Performative, &fipaMsg.Content)
	if response == nil {
		log.Println("No response generated by business logic")
		return
	}

	h.sendMessage(fipaMsg, response)
}

func (h *UniversalHandler) sendMessage(fipaMsg *FIPAMessage, response *BusinessLogicContext) {
	var content FipaContent
	if response.AdditionalInfo != nil {
		content = response.AdditionalInfo.(FipaContent)
	} else {
		log.Println("No additional info provided in response")
		return
	}

	responseMsg := NewFIPAMessage(
		fipaMsg.Nonce+1,
		fipaMsg.Protocol,
		response.Performative,
		fipaMsg.ConversationID,
		fipaMsg.ReplyWith,
		fipaMsg.ReplyBy,
		fipaMsg.InReplyWith,
		fipaMsg.Sender,
		fipaMsg.Receiver,
		content)

	h.agent.OutMessageQueue <- *gAgents.NewEnvelope(responseMsg)
}
